SOON

- update usage documentation

maintenance (as part of running "backup" or as separate "maintenance" command)
    - create historic full and merged delta backups 
    - ability to just trigger "backup" and have it not do anything if 
      the last backup is sufficiently new
    - delete backups according to schedule
    - clean out incorrect backups

- adapting to changing sizes is important to us as we resize volumes all the time
    - ensure resizing works properly over multiple deltas

- scrubbing: consistency between block sums and number of blocks
- scrubbing: chain of parent pointers
- does scrubbing validate the total checksum? (esp. for diffs?)

- what are our error conditions and follow up errors if a backup fails?
    - i can see that we loose the whole history if we update an existing full into a new delta and fail in between. need multiple atomic steps?

- keep a log of all backy operations (incl. scrubbing, etc)
- provide reasonable status output and history for monitoring tools and auditing
- implement posix locking on backup files to avoid conflicts


- allow rate-limitation on operations (e.g. max X blocks per seconds)
  to avoid overloading systems

  allow checking whether a certain number of backy jobs are already 
  running to delay operations


LATER

- fuse layer to enable direct (loop-mountable) access to old versions
- get fadvice back
- port gocept.directory "dynamic bytes" display

- reintegrate broken blocks that we have in older backups
- blocks in einem delta, die die gleiche checksumme haben (kommt durchaus vor) nur einmal speichern?

- review use of Python file's buffer argument (it should be 0 or chunk I think, but definitely not line-based)


QUESTIONABLE IDEAS

- ability to store blocks in a simple big pool using their hash?
-- may not be that helpful as we really want the primary full backups to 
   be directly, low-level copyable

- provide some level of filesystem integration to perform extended scrubbing, like running appropriate fscks

- implement detection which blocks are actually used by the filesystem and optionally limit backups (for thin provisioning)
  to those areas

- check /proc, /sys or some other interface to detect which blocks were written to

