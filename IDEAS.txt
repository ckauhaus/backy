

Storage format and operations

- ability to thin out (merge) older deltas
- keep multiple full backups?
- fuse layer to enable direct (loop-mountable) access to old versions
- ability to store blocks in a simple big pool using their hash?
-- may not be that helpful as we really want the primary full backups to 
   be directly, low-level copyable
- adapting to changing sizes is important to us as we resize volumes all the time
- keep checksums for blocks for diffs, too, and also allow scrubbing?
- use global revision checksums (sha) instead of enumerated revisions?
  keep metadata for time-association?

Reliability

- provide some level of filesystem integration to perform extended scrubbing, like running appropriate fscks.
- provide reasonable status output and history for monitoring tools and auditing
- implement posix locking on backup files to avoid conflicts
- we should be fsyncing
- should we be using sha instead of md5?
- add safety belt to avoid accidentally restoring into backup-managed files (e.g. by mixing up the parameters)
- does scrubbing validate the total checksum?
- can scrubbing especially for diffs validate block and total checksum?
- allow restoring (but warn about) inconsistent images


Optimizations

- get fadvice back
- implement detection which blocks are actually used by the filesystem and optionally limit backups (for thin provisioning)
  to those areas
- check /proc, /sys or some other interface to detect which blocks were written to
- make explicit use of Python file's buffer argument (it should be 0 or chunk I think, but definitely not line-based)

Usability

- port gocept.directory "dynamic bytes" display
- reverse numeration of UI and filenames on disk sounds like it might be
  confusing

Scheduling

- implement a scheduler for multiple sources (that can verify)

Configuration

- simple compound call/configuration (e.g. for many rbd volumes)

